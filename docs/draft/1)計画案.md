
 “GAS の Web エンドポイント = AI エージェント用の管理プロキシ” という形にすると、**ログイン中ユーザーの権限の範囲だけ**で他の GAS プロジェクトを「取得／更新／バージョン作成／デプロイ更新」できます。以下に即使える設計と最小実装をまとめました。

---

# ざっくり構成（2通り）

1. **推奨：GAS Web アプリを管理プロキシにする**
    

- ローカル（ClaudeCode 等）→ あなたの **GAS Web アプリ**（doPost）→ **Apps Script API（v1）**
    
- Web アプリを「**アクセスするユーザーとして実行**」にしておけば、そのユーザーがアクセス権を持つ GAS だけ操作可能（あなたの要件どおり）。
    
- Web アプリ内部で `ScriptApp.getOAuthToken()` を使い、Apps Script API を Bearer で直叩き。
    

2. 直接 API 叩く
    

- ローカルで OAuth（ユーザー同意）して Apps Script API を直接呼ぶ。
    
- ただし “AI エージェントからの統一インターフェース” としては 1) の方が扱いやすい（MCP のツール 1 個で済む）。
    

---

# 必要な権限（スコープ）

`appsscript.json` に少なくとも以下を入れます（管理操作用）：

```json
{
  "timeZone": "Asia/Tokyo",
  "exceptionLogging": "STACKDRIVER",
  "oauthScopes": [
    "https://www.googleapis.com/auth/script.projects",
    "https://www.googleapis.com/auth/script.deployments",
    "https://www.googleapis.com/auth/drive.readonly",
    "https://www.googleapis.com/auth/script.scriptapp",
    "https://www.googleapis.com/auth/script.external_request"
  ]
}
```

- `script.projects` …… プロジェクトの get/update、version 作成
    
- `script.deployments` …… デプロイ作成・更新・一覧
    
- `script.external_request` …… UrlFetchApp で Google API を叩くため
    
- `script.scriptapp` …… `getOAuthToken()` 用
    
- `drive.readonly` …… 場合によりスクリプトの所有・可視性確認で使うことがあります（任意）
    

**デプロイ設定**：Web アプリとして

- 実行するユーザー：**アクセスしているユーザー**
    
- アクセスできるユーザー：**ドメイン内/全員**（用途に応じ選択。外部クライアントから叩くなら “全員” 推奨。ただし認証は Google ログイン必須）
    

---

# エンドポイント設計（MCP 的に）

- URL：あなたの Web アプリの `doPost`
    
- 入力（JSON）：
    

```json
{
  "method": "getContent | updateContent | createVersion | createDeployment | listDeployments | updateDeployment | undeploy | ping",
  "params": {
    "scriptId": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    "description": "optional",
    "versionNumber": 1,
    "files": [
      {"name": "Code", "type": "SERVER_JS", "source": "function myFunction(){}"},
      {"name": "appsscript", "type": "JSON", "source": "{ \"timeZone\":\"Asia/Tokyo\" }"}
    ],
    "deploymentId": "AKfy........"
  }
}
```

- 出力（JSON）：
    

```json
{
  "ok": true,
  "data": { ...Apps Script API のレスポンス... },
  "error": null
}
```

---

# 最小実装（GAS：Code.gs）

> これを 1 ファイル貼って、manifest に前述スコープを入れ、Web アプリにデプロイで動きます。

```javascript
/**
 * GAS Web 管理プロキシ
 * - Apps Script API v1 をユーザー権限で叩く
 * - doPost(JSON) で method/params を受け付け
 */

const API_BASE = 'https://script.googleapis.com/v1';

/** 共通：Bearer 取得 */
function getBearer_() {
  // 必要スコープは appsscript.json に宣言
  return 'Bearer ' + ScriptApp.getOAuthToken();
}

/** 共通：HTTP 呼び出し */
function fetchJson_(url, opt) {
  const res = UrlFetchApp.fetch(url, {
    method: opt.method || 'get',
    contentType: 'application/json',
    muteHttpExceptions: true,
    payload: opt.body ? JSON.stringify(opt.body) : undefined,
    headers: Object.assign(
      { Authorization: getBearer_() },
      opt.headers || {}
    )
  });
  const text = res.getContentText();
  const code = res.getResponseCode();
  let json;
  try { json = text ? JSON.parse(text) : {}; } catch (e) { json = { raw: text }; }
  if (code >= 200 && code < 300) return json;
  // エラーはそのまま投げる
  throw new Error(`HTTP ${code}: ${text}`);
}

/** API ラッパ（主要操作） */
const api = {
  // プロジェクトのソース取得
  getContent(scriptId) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/content`;
    return fetchJson_(url, { method: 'get' });
  },
  // プロジェクトのソース更新（全置換）
  updateContent(scriptId, files) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/content`;
    return fetchJson_(url, {
      method: 'put',
      body: { files }
    });
  },
  // バージョン作成
  createVersion(scriptId, description) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/versions`;
    return fetchJson_(url, {
      method: 'post',
      body: { description: description || '' }
    });
  },
  // デプロイ作成（特定 versionNumber を公開）
  createDeployment(scriptId, versionNumber, description) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/deployments`;
    return fetchJson_(url, {
      method: 'post',
      body: {
        versionNumber,
        manifestFileName: 'appsscript',
        description: description || `Deploy v${versionNumber}`
      }
    });
  },
  // デプロイ一覧
  listDeployments(scriptId) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/deployments`;
    return fetchJson_(url, { method: 'get' });
  },
  // 既存デプロイの version を差し替え（PATCH）
  updateDeployment(scriptId, deploymentId, versionNumber, description) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/deployments/${encodeURIComponent(deploymentId)}`;
    return fetchJson_(url, {
      method: 'patch',
      body: {
        deploymentConfig: {
          scriptId,
          manifestFileName: 'appsscript',
          versionNumber,
          description: description || `Update to v${versionNumber}`
        }
      }
    });
  },
  // デプロイ削除（公開取り下げ）
  undeploy(scriptId, deploymentId) {
    const url = `${API_BASE}/projects/${encodeURIComponent(scriptId)}/deployments/${encodeURIComponent(deploymentId)}`;
    return fetchJson_(url, { method: 'delete' });
  }
};

/** ルーター */
function handle_(method, params) {
  switch (method) {
    case 'ping':
      return { pong: true, user: Session.getActiveUser().getEmail() || null };
    case 'getContent':
      return api.getContent(required_(params, 'scriptId'));
    case 'updateContent':
      return api.updateContent(required_(params, 'scriptId'), required_(params, 'files'));
    case 'createVersion':
      return api.createVersion(required_(params, 'scriptId'), params.description);
    case 'createDeployment':
      return api.createDeployment(
        required_(params, 'scriptId'),
        required_(params, 'versionNumber'),
        params.description
      );
    case 'listDeployments':
      return api.listDeployments(required_(params, 'scriptId'));
    case 'updateDeployment':
      return api.updateDeployment(
        required_(params, 'scriptId'),
        required_(params, 'deploymentId'),
        required_(params, 'versionNumber'),
        params.description
      );
    case 'undeploy':
      return api.undeploy(
        required_(params, 'scriptId'),
        required_(params, 'deploymentId')
      );
    default:
      throw new Error(`Unknown method: ${method}`);
  }
}

function required_(obj, key) {
  if (!obj || obj[key] === undefined || obj[key] === null) {
    throw new Error(`Missing required param: ${key}`);
  }
  return obj[key];
}

/** Webhook: POST JSON only（CORS 対応） */
function doPost(e) {
  try {
    const body = e.postData && e.postData.contents ? JSON.parse(e.postData.contents) : {};
    const result = handle_(body.method, body.params || {});
    return jsonOut_({ ok: true, data: result, error: null }, 200);
  } catch (err) {
    return jsonOut_({ ok: false, data: null, error: String(err) }, 400);
  }
}

function doGet() {
  // 動作確認用
  return jsonOut_({ ok: true, data: { ping: true }, error: null }, 200);
}

function jsonOut_(obj, code) {
  const out = ContentService.createTextOutput(JSON.stringify(obj));
  out.setMimeType(ContentService.MimeType.JSON);
  const resp = HtmlService.createHtmlOutput(); // ダミー（ヘッダ付与のため）
  const r = out; // テキスト出力に直接ヘッダは付けられないが、WebApp は CORS を緩く扱う
  // フロントから直接呼ぶなら、Google ログイン前提にするか、Apps Script 側で HTMLService 経由にする等を検討
  return r;
}
```

> **メモ**
> 
> - Apps Script API のファイル構造は `{name, type, source}` の配列です。`type` は `SERVER_JS`, `HTML`, `JSON`, `TS`, など。
>     
> - 自身のプロジェクトを更新することも技術的には可能ですが、**別プロジェクトを対象**にする運用が無難です。
>     

---

# 使い方（ローカルから）

### 1) プロジェクトの内容取得

```bash
curl -H "Content-Type: application/json" -X POST \
  -d '{
    "method": "getContent",
    "params": { "scriptId": "YOUR_SCRIPT_ID" }
  }' \
  "https://script.google.com/macros/s/AKfy.../exec"
```

### 2) プロジェクトの更新（全置換）

```bash
curl -H "Content-Type: application/json" -X POST \
  -d '{
    "method": "updateContent",
    "params": {
      "scriptId": "YOUR_SCRIPT_ID",
      "files": [
        {"name":"Code","type":"SERVER_JS","source":"function hello(){ Logger.log(\"hi\") }"},
        {"name":"appsscript","type":"JSON","source":"{ \"timeZone\":\"Asia/Tokyo\" }"}
      ]
    }
  }' \
  "https://script.google.com/macros/s/AKfy.../exec"
```

### 3) バージョン作成 → デプロイ

```bash
# version 作成
curl -H "Content-Type: application/json" -X POST \
  -d '{
    "method": "createVersion",
    "params": { "scriptId": "YOUR_SCRIPT_ID", "description": "v1" }
  }' \
  "https://script.google.com/macros/s/AKfy.../exec"

# レスポンスの versionNumber を使ってデプロイ
curl -H "Content-Type: application/json" -X POST \
  -d '{
    "method": "createDeployment",
    "params": { "scriptId": "YOUR_SCRIPT_ID", "versionNumber": 1, "description": "first deploy" }
  }' \
  "https://script.google.com/macros/s/AKfy.../exec"
```

---

# ClaudeCode / MCP ツールとして使う

MCP 的には “単一の HTTP ツール” として下記のようなスキーマにしておくとよいです（例）：

```json
{
  "name": "gas_admin",
  "description": "Manage Google Apps Script projects (get/update content, create versions, deployments).",
  "schema": {
    "type": "object",
    "properties": {
      "method": {
        "type": "string",
        "enum": [
          "ping",
          "getContent",
          "updateContent",
          "createVersion",
          "createDeployment",
          "listDeployments",
          "updateDeployment",
          "undeploy"
        ]
      },
      "params": { "type": "object" }
    },
    "required": ["method"]
  },
  "endpoint": "POST https://script.google.com/macros/s/AKfy.../exec",
  "auth": "Google session cookie / OAuth via browser"
}
```

> ClaudeCode 側のプロンプト指針
> 
> - “**常に** `scriptId` を明示せよ”
>     
> - “`updateContent` は**全置換**なので、最新の `getContent` を取得してから最小差分を作って送ること”
>     
> - “`createVersion` → `createDeployment` の順で公開。既存公開の差し替えは `listDeployments` → `updateDeployment`”
>     
> - “レスポンスの `ok` が false のときは `error` をユーザーに可視化して再試行ポリシー（最大 2 回）”
>     

---

# セキュリティと運用の注意

- **ユーザー権限で実行**：Web アプリは “アクセスするユーザーとして実行” に設定することで、**そのユーザーがアクセス権を持つプロジェクトのみ**操作できます（要件◎）。
    
- **CORS**：ローカル CLI（Node/Curl）なら不要。ブラウザ直接呼び出しをするなら、`google.com` ドメインの認証フローに依存するため SPA 直呼びは避け、CLI/サーバー経由推奨。
    
- **差分更新**：`updateContent` は全置換なので、**誤って他ファイルを消さない**ように、クライアント側でマージ／差分生成を徹底。
    
- **レート制限/クォータ**：Apps Script API にクォータあり。バッチ的に連続更新する場合は 429/5xx リトライを実装。
    
- **自己更新**：この “管理プロキシ” 自身を `updateContent` で書き換えることはできるが、失敗時に復旧が面倒。**別プロジェクト（管理者）→ 対象プロジェクト**の形を推奨。
    
- **CLASP との併用**：既存リポと同期する必要があれば CLASP（google/clasp）も併用可能。AI は “Web プロキシ優先／CLASP fallback” の二段構えが安定。
    

---

# 追加で欲しければ出せるもの

- Node/TS のクライアント SDK（型付き）
    
- `updateContent` 用の **安全な三方差分マージ**ユーティリティ
    
- ClaudeCode / Cursor の MCP ツール定義テンプレ（すぐ読み込める JSON）
    

---

**結論**：この方式なら、**AI エージェントから安全に GAS を直接更新・デプロイ**できます。上の最小実装をそのまま貼り、Web アプリ公開 → ローカルから `method/params` を投げるだけで運用スタート可能です。