
ローカル側は**ワンコマンド導入＋プロファイル切替**でいきましょう。  
下は**依存ゼロ（Node.jsだけ）**の最小CLIです。セットアップを再実行すると、**アカウント（プロファイル）を追加・切替**できます。

---

# 方針（2モード対応）

- **User-Session モード（推奨）**
    
    - 管理プロキシ（GAS Webアプリ）が「**アクセスしているユーザーとして実行**」。
        
    - CLI は `ping` を叩いてログイン確認（ブラウザで一度アクセス→認証）。
        
    - エンドポイントは `…/exec` のみ。ヘッダのシークレットは不要。
        
- **Owner-Proxy モード（代行運用）**
    
    - 管理プロキシが「**自分として実行**＋全員に公開」。
        
    - `X-Admin-Token` で許可リスト＆防御（`doPost`側にチェックを実装済み想定）。
        
    - ローカルからはトークンを付けて直叩き。複数アカウントの切替＝プロファイル切替で表現。
        

> 両モードを**プロファイル**として保存し、切り替え運用できます。

---

# セットアップ（コピペでOK）

1. 空のフォルダに次の2ファイルを作成:
    

## `package.json`

```json
{
  "name": "gas-admin-cli",
  "version": "0.1.0",
  "type": "module",
  "bin": {
    "gas-admin": "./cli.js"
  }
}
```

## `cli.js`

```javascript
#!/usr/bin/env node
import fs from 'fs';
import os from 'os';
import path from 'path';
import readline from 'readline/promises';
import { stdin as input, stdout as output } from 'process';
import https from 'https';
import http from 'http';
import { URL } from 'url';

const CONFIG_DIR = path.join(os.homedir(), '.gas-admin');
const CONFIG_PATH = path.join(CONFIG_DIR, 'config.json');

function loadConfig() {
  if (!fs.existsSync(CONFIG_PATH)) return { active: null, profiles: {} };
  return JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
}
function saveConfig(cfg) {
  fs.mkdirSync(CONFIG_DIR, { recursive: true });
  fs.writeFileSync(CONFIG_PATH, JSON.stringify(cfg, null, 2));
}

function pick(obj, ...keys) { const r = {}; keys.forEach(k=>{ if(obj[k]!=null) r[k]=obj[k];}); return r; }

async function promptSetup(existingName=null) {
  const rl = readline.createInterface({ input, output });
  console.log('\n=== GAS Admin CLI Setup ===');
  const profileName = existingName || await rl.question(`Profile name [default]: `) || 'default';
  const endpoint = await rl.question(`Web App endpoint (…/exec): `);
  if (!endpoint) { console.error('Endpoint is required.'); process.exit(1); }
  const mode = (await rl.question(`Mode: [1] User-Session (no token)  [2] Owner-Proxy (with X-Admin-Token) [1/2]: `) || '1').trim();
  let adminToken = '';
  if (mode === '2') {
    adminToken = await rl.question(`X-Admin-Token (same as WebApp server): `);
    if (!adminToken) { console.error('Admin token required for Owner-Proxy mode.'); process.exit(1); }
  }
  const defaultScriptId = await rl.question(`(Optional) Default scriptId: `);
  rl.close();

  const cfg = loadConfig();
  cfg.profiles[profileName] = {
    endpoint,
    mode: mode === '2' ? 'owner-proxy' : 'user-session',
    adminToken: mode === '2' ? adminToken : null,
    defaultScriptId: defaultScriptId || null
  };
  cfg.active = profileName;
  saveConfig(cfg);
  console.log(`\nSaved profile "${profileName}" and set as active.\n`);
}

function getActiveProfileOrExit() {
  const cfg = loadConfig();
  if (!cfg.active || !cfg.profiles[cfg.active]) {
    console.error('No active profile. Run: gas-admin setup');
    process.exit(1);
  }
  return { cfg, prof: cfg.profiles[cfg.active] };
}

function httpJson(urlStr, method, body, headers = {}) {
  return new Promise((resolve, reject) => {
    const u = new URL(urlStr);
    const isHttps = u.protocol === 'https:';
    const data = body ? JSON.stringify(body) : null;
    const opts = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...(data ? { 'Content-Length': Buffer.byteLength(data) } : {}),
        ...headers
      }
    };
    const lib = isHttps ? https : http;
    const req = lib.request(u, opts, res => {
      let buf = '';
      res.on('data', d => buf += d);
      res.on('end', () => {
        const code = res.statusCode || 0;
        let json;
        try { json = buf ? JSON.parse(buf) : {}; } catch(e) { json = { raw: buf }; }
        if (code >= 200 && code < 300) resolve(json);
        else reject(new Error(`HTTP ${code}: ${buf}`));
      });
    });
    req.on('error', reject);
    if (data) req.write(data);
    req.end();
  });
}

async function callProxy(method, params) {
  const { prof } = getActiveProfileOrExit();
  const headers = {};
  if (prof.mode === 'owner-proxy' && prof.adminToken) {
    headers['X-Admin-Token'] = prof.adminToken; // サーバ側で検証する想定
  }
  const payload = { method, params };
  return httpJson(prof.endpoint, 'POST', payload, headers);
}

function usage() {
  console.log(`
gas-admin <command> [options]

Commands:
  setup                         初期設定/プロファイル追加（再実行で追加・上書き）
  profile:list                  プロファイル一覧
  profile:use <name>            アクティブプロファイル切替
  whoami                        接続確認 (ping)
  get <scriptId?>               プロジェクトのソース取得
  update <scriptId?> <file>     JSONファイルで updateContent（全置換）
  run <scriptId?> <func> [args JSON]   関数実行（devMode:true）
  version <scriptId?> <desc>    バージョン作成
  deploy <scriptId?> <version> [desc]  デプロイ作成
  depl:list <scriptId?>         デプロイ一覧
  depl:update <scriptId?> <deploymentId> <version> [desc]
  trig:list <scriptId?>         トリガー一覧（AdminShim 必要）
  trig:add <scriptId?> <handler> [everyMin=5]
  trig:del <scriptId?> <handler>
  prop:list <scriptId?> [store=script]
  prop:set  <scriptId?> <store> <jsonProps>
  prop:del  <scriptId?> <store> <key>

Examples:
  gas-admin setup
  gas-admin profile:use work
  gas-admin whoami
  gas-admin get 1AbCdEfGhI...
  gas-admin update 1AbCdEfGhI... files.json
  gas-admin run 1AbCdEfGhI... main '["arg1",2]'
  gas-admin version 1AbCdEfGhI... "v1"
  gas-admin deploy 1AbCdEfGhI... 3 "release v1"
`);
}

function resolveScriptId(arg) {
  const { prof } = getActiveProfileOrExit();
  return arg || prof.defaultScriptId || (() => { console.error('scriptId required (or set default in profile).'); process.exit(1); })();
}

async function main() {
  const [,, cmd, ...rest] = process.argv;
  if (!cmd || cmd === 'help' || cmd === '--help' || cmd === '-h') { usage(); return; }

  if (cmd === 'setup') { await promptSetup(); return; }
  if (cmd === 'profile:list') {
    const cfg = loadConfig();
    console.log('Profiles:');
    Object.keys(cfg.profiles).forEach(name => {
      const mark = (cfg.active === name) ? '*' : ' ';
      console.log(` ${mark} ${name} -> ${cfg.profiles[name].mode} @ ${cfg.profiles[name].endpoint}`);
    });
    return;
  }
  if (cmd === 'profile:use') {
    const name = rest[0];
    const cfg = loadConfig();
    if (!name || !cfg.profiles[name]) { console.error('Profile not found.'); process.exit(1); }
    cfg.active = name;
    saveConfig(cfg);
    console.log(`Switched to profile "${name}".`);
    return;
  }

  // Commands requiring an active profile:
  try {
    switch (cmd) {
      case 'whoami': {
        const res = await callProxy('ping', {});
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'get': {
        const scriptId = resolveScriptId(rest[0]);
        const res = await callProxy('getContent', { scriptId });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'update': {
        const scriptId = resolveScriptId(rest[0]);
        const file = rest[1];
        if (!file) { console.error('files.json path required'); process.exit(1); }
        const files = JSON.parse(fs.readFileSync(file, 'utf-8'));
        const res = await callProxy('updateContent', { scriptId, files });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'run': {
        const scriptId = resolveScriptId(rest[0]);
        const func = rest[1];
        const args = rest[2] ? JSON.parse(rest[2]) : [];
        const res = await callProxy('run', { scriptId, functionName: func, parameters: args, devMode: true });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'version': {
        const scriptId = resolveScriptId(rest[0]);
        const desc = rest.slice(1).join(' ') || '';
        const res = await callProxy('createVersion', { scriptId, description: desc });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'deploy': {
        const scriptId = resolveScriptId(rest[0]);
        const versionNumber = parseInt(rest[1], 10);
        const desc = rest.slice(2).join(' ') || '';
        if (!versionNumber) { console.error('versionNumber required'); process.exit(1); }
        const res = await callProxy('createDeployment', { scriptId, versionNumber, description: desc });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'depl:list': {
        const scriptId = resolveScriptId(rest[0]);
        const res = await callProxy('listDeployments', { scriptId });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'depl:update': {
        const scriptId = resolveScriptId(rest[0]);
        const deploymentId = rest[1];
        const versionNumber = parseInt(rest[2], 10);
        const desc = rest.slice(3).join(' ') || '';
        if (!deploymentId || !versionNumber) { console.error('deploymentId and versionNumber required'); process.exit(1); }
        const res = await callProxy('updateDeployment', { scriptId, deploymentId, versionNumber, description: desc });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'trig:list': {
        const scriptId = resolveScriptId(rest[0]);
        const res = await callProxy('listTriggers', { scriptId });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'trig:add': {
        const scriptId = resolveScriptId(rest[0]);
        const handler = rest[1];
        const every = parseInt(rest[2] || '5', 10);
        const res = await callProxy('createTimeTrigger', { scriptId, handlerFunction: handler, everyMinutes: every });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'trig:del': {
        const scriptId = resolveScriptId(rest[0]);
        const handler = rest[1];
        const res = await callProxy('deleteTriggerByFunction', { scriptId, handlerFunction: handler });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'prop:list': {
        const scriptId = resolveScriptId(rest[0]);
        const store = rest[1] || 'script';
        const res = await callProxy('listProperties', { scriptId, store });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'prop:set': {
        const scriptId = resolveScriptId(rest[0]);
        const store = rest[1];
        const props = JSON.parse(rest[2] || '{}');
        const res = await callProxy('setProperties', { scriptId, store, props });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      case 'prop:del': {
        const scriptId = resolveScriptId(rest[0]);
        const store = rest[1];
        const key = rest[2];
        const res = await callProxy('deleteProperty', { scriptId, store, key });
        console.log(JSON.stringify(res, null, 2));
        break;
      }
      default:
        usage();
    }
  } catch (e) {
    console.error(String(e));
    process.exit(1);
  }
}

main();
```

2. インストール（ローカルのみ）
    

```bash
npm i
chmod +x cli.js
npm link   # or: npx ./cli.js
```

---

# 使い方（超速チートシート）

- 初期セットアップ（プロファイル作成 & アクティブ化）
    

```bash
gas-admin setup
# 質問に答える: プロファイル名 / WebAppエンドポイント / モード / トークン / デフォルトscriptId
```

- プロファイルを増やす（= アカウント切替準備）
    

```bash
gas-admin setup         # 別名で追加（例: work, personal）
gas-admin profile:list  # 一覧
gas-admin profile:use work
```

- 疎通確認
    

```bash
gas-admin whoami
```

- 取得 / 更新 / 実行 / デプロイ
    

```bash
gas-admin get                # defaultScriptId を使う
gas-admin get 1AbCdEf...     # 明示してもOK

# files.json は Apps Script API 形式の files 配列（[{name,type,source},...])
gas-admin update 1AbCdEf... files.json

gas-admin run 1AbCdEf... myFunction '["arg1",2]'
gas-admin version 1AbCdEf... "v1"
gas-admin deploy 1AbCdEf... 3 "release v1"
```

- トリガー / プロパティ（AdminShim 必須）
    

```bash
gas-admin trig:list 1AbCdEf...
gas-admin trig:add  1AbCdEf... tick 5
gas-admin trig:del  1AbCdEf... tick

gas-admin prop:list 1AbCdEf... script
gas-admin prop:set  1AbCdEf... script '{"API_KEY":"xxx","ENV":"prod"}'
gas-admin prop:del  1AbCdEf... script API_KEY
```

---

# プロファイルとアカウント切替の実際

- 設定は `~/.gas-admin/config.json` に保存され、**複数プロファイル**（例：`work`, `personal`）を持てます。
    
- `gas-admin setup` を**再実行**すると、
    
    - 既存名 → 上書き更新
        
    - 新しい名 → 追加  
        → その時点で**アクティブ**が切り替わります（=アカウント切替の擬似表現）。
        
- `profile:use <name>` で瞬時に切替。
    
- **User-Session モードのアカウント**は、**ブラウザのGoogleログイン状態**に従います。
    
    - もし違うGoogleアカウントで権限を使いたい時は、WebアプリURLをブラウザで開いて**そのアカウント**で承認→`whoami`で確認。
        
    - CLI自体はクッキーを扱わず、Webアプリ側でログイン必須（匿名不可）にしておくのが安全です。
        
- **Owner-Proxy モード**は、Webアプリの実行者が固定（あなた）なので、切替は**プロファイルの `X-Admin-Token` / エンドポイント**で表現します。
    

---

# 便利Tips

- **バックアップ自動化**：`gas-admin get > backup.json` → 編集 → `gas-admin update ... files.json`。
    
- **安全更新**：AIに任せる前に `get` の結果をローカルGit管理しておくとロールバック容易。
    
- **差分更新**：最小実装は全置換ですが、必要なら差分マージユーティリティ（3方差分）を後付け可能。
    
- **HTMLテンプレ同梱**：`files.json` に `"type":"HTML"` を混ぜるだけでOK（`Index.html`など）。
    
- **デプロイ差し替え**：`depl:list` で `deploymentId` を取得 → `depl:update` で version 切替。
    

---

必要なら、このCLIに**`ensureAdminShim`**（対象プロジェクトへ自動注入）や**三方差分**を足した拡張版も出します。  
まずはこの最小構成で「導入簡易化＋プロファイル切替」を即運用できます。