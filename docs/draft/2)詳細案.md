
下記を足すだけで「実行エラー／ログ」「トリガー操作」「プロパティ操作」「HTMLテンプレのアップ」がAI向けに扱えるようになります。

---

# 1) 実行（scripts.run）とエラー整形

### 追加スコープ（管理プロキシ側の `appsscript.json`）

（前回のに**既に含め済み**ですが念のため）

```json
"https://www.googleapis.com/auth/script.projects",
"https://www.googleapis.com/auth/script.scriptapp",
"https://www.googleapis.com/auth/script.external_request"
```

### 追記：実行APIラッパ & 正規化レスポンス

```javascript
// 実行API
api.run = function run(scriptId, functionName, parameters, devMode) {
  const url = `${API_BASE}/scripts/${encodeURIComponent(scriptId)}:run`;
  return fetchJson_(url, {
    method: 'post',
    body: {
      function: functionName,           // 実行する関数名
      parameters: parameters || [],     // 配列で渡す
      devMode: devMode === true         // true なら最新コードを即実行（未バージョンでもOK）
    }
  });
};

// scripts.run の生レスポンスを AI 向けに正規化
function normalizeRunResult_(raw) {
  // 正常系: { response: { result: any } , ... , "log": ["..."] }
  if (raw && raw.response) {
    return {
      ok: true,
      result: raw.response.result ?? null,
      logs: raw.log || [],
      error: null,
      meta: {
        executionId: raw.executionId || null
      }
    };
  }
  // 例外系: { error: { details: [ { errorMessage, errorType, scriptStackTraceElements: [ {function, lineNumber} ] } ] } }
  if (raw && raw.error && raw.error.details && raw.error.details.length) {
    const d = raw.error.details[0] || {};
    return {
      ok: false,
      result: null,
      logs: raw.log || [],
      error: {
        message: d.errorMessage || 'Script error',
        type: d.errorType || 'ERROR',
        stack: (d.scriptStackTraceElements || []).map(s => ({
          func: s.function || null,
          line: s.lineNumber || null
        }))
      },
      meta: {
        executionId: raw.executionId || null
      }
    };
  }
  // それ以外のHTTP系エラーは fetchJson_ 側で throw になる→ doPost で JSON 化済み
  return { ok: false, result: null, logs: [], error: { message: 'Unknown run response' }, meta: {} };
}
```

### ルーターに追記

```javascript
case 'run':
  // devMode=true で最新版即実行（未バージョンでもデバッグ向き）
  return normalizeRunResult_(api.run(
    required_(params, 'scriptId'),
    required_(params, 'functionName'),
    params.parameters || [],
    params.devMode === true
  ));
```

> これで**関数実行のログ**・**スタックトレース**・**実行ID**をAIに返せます。AIは `ok:false` のとき `error.stack` を読み、該当行の修正提案まで自動化できます。

---

# 2) トリガー & プロパティ操作（管理用シム）

REST APIに**トリガー/PropertiesServiceの直接エンドポイントはありません**。なので**対象GAS内に管理用シム**を1ファイル入れて、`scripts.run` で呼ぶのが最短・確実です。

### 管理用シム（対象プロジェクトに1回だけ入れる）

`AdminShim.gs`（任意名）を **対象GAS** に追加（あなたのAIが `updateContent` で同梱してOK）

```javascript
/** Admin shim inside target GAS project */

// -------- Triggers --------
function admin_listTriggers() {
  return ScriptApp.getProjectTriggers().map(t => ({
    id: t.getUniqueId ? t.getUniqueId() : null, // Web triggers have no id pre-2024; newer runtime exposes getUniqueId
    handlerFunction: t.getHandlerFunction(),
    type: String(t.getEventType && t.getEventType()),
    minuteInterval: t.getTriggerSourceId ? null : null // keep for future expansion
  }));
}

function admin_createTimeTrigger(handlerFunction, everyMinutes) {
  var b = ScriptApp.newTrigger(handlerFunction).timeBased();
  if (everyMinutes && everyMinutes >= 1 && everyMinutes <= 60) {
    b = b.everyMinutes(everyMinutes);
  } else {
    b = b.everyHours(1);
  }
  var trig = b.create();
  return { handlerFunction: handlerFunction, id: trig.getUniqueId ? trig.getUniqueId() : null };
}

function admin_deleteTriggerByFunction(handlerFunction) {
  var count = 0;
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === handlerFunction) {
      ScriptApp.deleteTrigger(t);
      count++;
    }
  });
  return { deleted: count };
}

// -------- Properties --------
function admin_listProperties(store) {
  var p = pickStore_(store);
  return p.getProperties();
}

function admin_setProperties(store, obj) {
  var p = pickStore_(store);
  p.setProperties(obj, true);
  return { ok: true };
}

function admin_deleteProperty(store, key) {
  var p = pickStore_(store);
  p.deleteProperty(key);
  return { ok: true };
}

function pickStore_(store) {
  switch ((store || 'script').toLowerCase()) {
    case 'user': return PropertiesService.getUserProperties();
    case 'document': return PropertiesService.getDocumentProperties();
    default: return PropertiesService.getScriptProperties();
  }
}
```

> 初回実行時に対象GASが `ScriptApp` / `PropertiesService` の権限を要求する場合があります（ユーザー承認でOK）。

### 管理プロキシ（今回のWebアプリ）からの呼び出し

ルーターに以下を追記：

```javascript
case 'listTriggers':
  return normalizeRunResult_(api.run(required_(params, 'scriptId'), 'admin_listTriggers', [], true));

case 'createTimeTrigger':
  return normalizeRunResult_(api.run(
    required_(params, 'scriptId'),
    'admin_createTimeTrigger',
    [ required_(params, 'handlerFunction'), params.everyMinutes || 60 ],
    true
  ));

case 'deleteTriggerByFunction':
  return normalizeRunResult_(api.run(
    required_(params, 'scriptId'),
    'admin_deleteTriggerByFunction',
    [ required_(params, 'handlerFunction') ],
    true
  ));

case 'listProperties':
  return normalizeRunResult_(api.run(
    required_(params, 'scriptId'),
    'admin_listProperties',
    [ params.store || 'script' ],
    true
  ));

case 'setProperties':
  return normalizeRunResult_(api.run(
    required_(params, 'scriptId'),
    'admin_setProperties',
    [ params.store || 'script', required_(params, 'props') ],
    true
  ));

case 'deleteProperty':
  return normalizeRunResult_(api.run(
    required_(params, 'scriptId'),
    'admin_deleteProperty',
    [ params.store || 'script', required_(params, 'key') ],
    true
  ));
```

> これで AI は **「管理シムが入っていれば」** トリガーとプロパティをフル操作できます。  
> シム未導入なら、AIは `getContent` → `AdminShim.gs` の有無を確認 → なければ `updateContent` に差し込み → 再実行、というワークフローにすればOK。

---

# 3) HTMLテンプレートのアップ（テンプレ反映）

`updateContent` の `files` で `type: "HTML"` を使えばOK。複数テンプレも可。

```json
{
  "method": "updateContent",
  "params": {
    "scriptId": "YOUR_SCRIPT_ID",
    "files": [
      {"name":"Index","type":"HTML","source":"<!DOCTYPE html><html><body><?= name ?></body></html>"},
      {"name":"Code","type":"SERVER_JS","source":"function doGet(){ return HtmlService.createTemplateFromFile('Index').evaluate().setTitle('Demo'); }"},
      {"name":"appsscript","type":"JSON","source":"{ \"timeZone\": \"Asia/Tokyo\" }"}
    ]
  }
}
```

> 以後 `HtmlService.createTemplateFromFile('Index')` でレンダリング可能。AIはテンプレと `.gs` の両方を同時に上げられます。

---

# 4) AIエージェント向けのレスポンス仕様（拡張）

**統一レスポンス**（成功/失敗どちらでも同じ形）にするのがポイント：

```json
{
  "ok": true,
  "data": { ... },         // メソッド固有結果（getContent等） or run 正常時 result
  "error": null,
  "logs": ["..."],         // scripts.run のログ（run系のみ）
  "meta": {
    "executionId": "ABC...", // run系のみ
    "hint": "next action suggestions..." // 任意：クライアントが出す
  }
}
```

- **updateContent** は破壊的（全置換）なので、AI側は「直前の `getContent` を保存 → 失敗時に復旧」フローを推奨。
    
- **run のエラー**は `ok:false` で `error.message / error.type / error.stack[]` を返しているので、AIは
    
    1. `stack[0]` の `line` を修正候補提示
        
    2. `logs` を要約
        
    3. 自動テストで再実行  
        …という再試行戦略を素直に書けます。
        

---

# 5) 代表的な呼び出し例（curl）

### a) 関数を最新版でデバッグ実行（ログ・エラー取得）

```bash
curl -H "Content-Type: application/json" -X POST \
  -d '{
    "method": "run",
    "params": {
      "scriptId": "YOUR_SCRIPT_ID",
      "functionName": "main",
      "parameters": ["arg1", 2],
      "devMode": true
    }
  }' \
  "https://script.google.com/macros/s/AKfy.../exec"
```

### b) トリガー一覧 → 5分おきトリガー作成 → ハンドラ削除

```bash
# 一覧
curl -H "Content-Type: application/json" -X POST \
  -d '{"method":"listTriggers","params":{"scriptId":"YOUR_SCRIPT_ID"}}' \
  "https://script.google.com/macros/s/AKfy.../exec"

# 作成
curl -H "Content-Type: application/json" -X POST \
  -d '{"method":"createTimeTrigger","params":{"scriptId":"YOUR_SCRIPT_ID","handlerFunction":"tick","everyMinutes":5}}' \
  "https://script.google.com/macros/s/AKfy.../exec"

# 削除（ハンドラ名で一括）
curl -H "Content-Type: application/json" -X POST \
  -d '{"method":"deleteTriggerByFunction","params":{"scriptId":"YOUR_SCRIPT_ID","handlerFunction":"tick"}}' \
  "https://script.google.com/macros/s/AKfy.../exec"
```

### c) スクリプト／ユーザー／ドキュメントプロパティ

```bash
# 一覧
curl -H "Content-Type: application/json" -X POST \
  -d '{"method":"listProperties","params":{"scriptId":"YOUR_SCRIPT_ID","store":"script"}}' \
  "https://script.google.com/macros/s/AKfy.../exec"

# まとめて設定（上書きマージ）
curl -H "Content-Type: application/json" -X POST \
  -d '{"method":"setProperties","params":{"scriptId":"YOUR_SCRIPT_ID","store":"script","props":{"API_KEY":"xxx","ENV":"prod"}}}' \
  "https://script.google.com/macros/s/AKfy.../exec"

# 1件削除
curl -H "Content-Type: application/json" -X POST \
  -d '{"method":"deleteProperty","params":{"scriptId":"YOUR_SCRIPT_ID","store":"script","key":"API_KEY"}}' \
  "https://script.google.com/macros/s/AKfy.../exec"
```

---

# 6) AI（MCP）側の運用ヒント

- **ポリシー**
    
    1. まず `getContent` でバックアップ
        
    2. 差分生成 → `updateContent`（必要なら AdminShim を差し込む）
        
    3. `run(devMode:true)` でユニットテスト関数を実行 → ログ・スタック解析
        
    4. エラーなら自動修正して再試行（最大2回）
        
    5. 安定後 `createVersion` → 既存デプロイ差し替え（`listDeployments`→`updateDeployment`）
        
- **スキーマ**
    
    - `method` は enum で固定
        
    - `params.scriptId` は**必須**
        
    - `run` の `functionName` / `parameters` は**必須**
        
    - `listProperties/setProperties/deleteProperty` の `store` は `"script"|"user"|"document"` のいずれか
        
- **UX**
    
    - `logs` をそのまま出すとノイズになりやすいので、AI側で「INFO/ERROR のみ抽出」 → 要約
        
    - `error.stack` の先頭エレメントから、対象ファイルの該当行のソースを `getContent` 結果で抜いて、差分提案を自動生成
        

---

# 7) まとめ

- **実行エラー／ログ**：`scripts.run` + `normalizeRunResult_` でAIが扱いやすいJSONに整形
    
- **トリガー／プロパティ**：対象GASに**管理シム**（数十行）を同梱 → `run` 経由で完全遠隔操作
    
- **HTMLテンプレ**：`type:"HTML"` で `updateContent` に同梱アップロード
    
- **AI応答設計**：`{ok,data,error,logs,meta}` の統一フォーマットで安定的に再試行・自動修正が可能
    

必要なら、**管理シムを自動注入する「ensureAdminShim」メソッド**や、**差分マージの安全ユーティリティ（3方差分）**、**MCPツールJSON**もそのまま出せます。